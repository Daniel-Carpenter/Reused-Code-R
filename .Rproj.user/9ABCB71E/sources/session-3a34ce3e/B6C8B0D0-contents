# Read Commonly Used Library and Reusable Functions
source('Reused-Code//Read-Data-and-Library.R')



# INPUTS =======================================================================

bigBusiness = c("WS")

minDate = as.Date('2020-06-02')
maxDate = as.Date('2024-02-01')
removeBusinesses = c('PV', 'TX', 'WG', 'AW', 'MG') # WIGOS transfered


highlightDatesAfter = as.Date('2024-01-01')
metricStrWrap = 20

selectedMonth = 1

comparisonYears = c(2023)


# DATA =========================================================================


## DATABASE CONNECTION =========================================================

# Connect to the database                  # Connection using `dbplyr`:
con <- tbl(database,                       # The database
           in_schema(schema = 'BUDGET',    # The schema
           table  = 'DailyRevenueTracker'))# The table



# DATA PULL ===================================================================

result <- con  |>

  # Filter the data to date ranges
  filter(FORECAST_DATE >= minDate & FORECAST_DATE < maxDate) %>%

  # Keep a few columns and rename
  select(SOURCE_PROP,
         GAMING_DATE = FORECAST_DATE,
         COIN_IN     = COIN_IN_ACTUAL,
         NET_WIN     = NET_WIN_ACTUAL,
         FREEPLAY    = FREEPLAY_ACTUAL
         ) |>
  
  # Set freeplay as an expense
  mutate(FREEPLAY = -FREEPLAY) |> 

  collect()

# write_rds(result, 'Business-Performance/data.rds')
# result <- read_rds('Business-Performance/data.rds')


## DATA PREP ===================================================================
df <- result |> 
  
  # remove wigos. Done here since dplyr cannot do IN on sql server 
  filter(!(SOURCE_PROP %in% removeBusinesses)) |> 
  
  # Factor lump the largest businesses
  mutate(isBigBusiness = SOURCE_PROP %in% bigBusiness,
         SOURCE_PROP_GROUP = if_else(isBigBusiness, SOURCE_PROP, "All Other Bally's Properties"),
         SOURCE_PROP_GROUP = if_else(SOURCE_PROP_GROUP == 'WS', 'WinStar', SOURCE_PROP_GROUP)
  ) |> 
         
  
  # Group data by end of month, source prop grouping, and asset class
  group_by(GAMING_DATE,
           SOURCE_PROP_GROUP
           ) |> 
    
  # Sum or create performance metrics
  summarise(
    COIN_IN       = sum(COIN_IN,  na.rm = TRUE),
    FREE_PLAY      = sum(FREEPLAY, na.rm = TRUE),
    NET_WIN       = sum(NET_WIN,  na.rm = TRUE),
  ) |> 
  
  mutate(highlightedDates = GAMING_DATE >= highlightDatesAfter) |> 
    
  # Put values into single column for dynamic plotting
  pivot_longer(cols = where(is.numeric),
               names_to = 'metric',
               values_to = 'value') |>

  # Clean up names
  mutate(metric = str_replace_all(metric, '_', ' '),
         metric = str_to_title(metric),
         SOURCE_PROP_GROUP = as.factor(str_wrap(SOURCE_PROP_GROUP, metricStrWrap)),
         dayOfWeek = wday(GAMING_DATE, label = TRUE)
  )

df$SOURCE_PROP_GROUP = factor(df$SOURCE_PROP_GROUP, levels = rev(unique(df$SOURCE_PROP_GROUP)))

# Get the median values per day of week PRIOR to highlighted date range
df_medianPre <- df |> 
  filter(!highlightedDates,
         month(GAMING_DATE) == selectedMonth,
         year(GAMING_DATE) %in% comparisonYears
         
         ) |> 
  group_by(SOURCE_PROP_GROUP,
           dayOfWeek,
           metric
           ) |>
  summarise(median_value = median(value))

# Get theaverage values per day of week DURING the highlighted date range
df_avg <- df |> 
  filter(highlightedDates) |> 
  group_by(SOURCE_PROP_GROUP,
           dayOfWeek,
           metric
           ) |>
  summarise(avg_value = mean(value)) |> 
  
  # Join the median data (prior to the highlighted date range)
  left_join(df_medianPre,
            by = c('SOURCE_PROP_GROUP',
                   'dayOfWeek',
                   'metric')) |> 
  mutate(avgExceedsMedian = if_else(avg_value > median_value, 'Above Median', 'Below Median'))



# PLOTS ========================================================================


# Filter boxplot date to prior to highlighted dates AND to only single month
df_plot <- df |>
  filter(!highlightedDates,
         month(GAMING_DATE) == selectedMonth,
         year(GAMING_DATE) %in% comparisonYears
         
         )

millionsOfDollars <- function(x) dollar(x / 1e6, prefix = "$", suffix = " M")

  
chosenMonthName = paste0(unique(month(df_plot$GAMING_DATE, label = TRUE, abbr = FALSE) ))
legendTitle = paste(chosenMonthName, 'Compared to Historical Median')

  # Map variables to plot
ggplot() +
  
  # old data points
  geom_point(data = df_plot,
             aes(y = value, 
                                x = dayOfWeek
                                ),
             color = scale_cmac('gray', 'gray4'),
             alpha = 0.4,
             size = 2.5
             ) +
  
  # avg points
  geom_point(data = df_avg,
             aes(y = avg_value, 
                 x = dayOfWeek,
                 fill = avgExceedsMedian,
                 color = avgExceedsMedian
             ),
             pch = 21,
             size = 4,
             alpha = 0.9,
             stroke = 0.66 # The width of the border, i.e. stroke.
             ) +
  
  
  # Labels
  labs(title    = 'Weekday Average Performance\n',
       subtitle = paste('January 2024 vs. January 2023\n'),
       x        = '',
       y        = '',
       color    = legendTitle,
       fill     = legendTitle,
       ) +
  
  # Facetting
  facet_grid(cols = vars(SOURCE_PROP_GROUP),
             rows = vars(metric),
             scales = 'free_y',
             switch = "y"
             ) +
  
  # Axis formats
  scale_y_continuous(labels = millionsOfDollars) +
  
  # Theme
  scale_fill_manual( values = scale_cmac('fill',  'blue', 'red')) +
  scale_color_manual(values = scale_cmac('color', 'blue', 'red')) +
  theme_cmac(borderMode = 'facet',
             inTimesNewRoman = T) +
  
  # Additional theme
  theme(legend.position = 'top',
        legend.title = element_text(color = scale_cmac('text')),
        strip.placement = "outside", # Ensures labels are outside the plot area
        # strip.text.y = element_text(size = 12, hjust = 1, vjust = 1),
        strip.text.x = element_text(vjust = 1),
        # axis.text.x = element_text(hjust = 1),
        panel.spacing.x = unit(1.25, "lines"),
        panel.spacing.y = unit(2, "lines")
        )


exportToPNG(cowplot::plot_grid(last_plot()), 
            outputFileName =   'Business-Performance/Visualizations/Weekday-Performance',
            outHeight      =   1100,
            outWidth       =   1100,
            outResolution  =   120,
            SCALED_BY      =   8
)
