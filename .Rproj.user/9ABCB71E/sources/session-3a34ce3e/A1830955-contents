# Read Commonly Used Library and Reusable Functions
source('Reused-Code//Read-Data-and-Library.R')




# inputs -----------------------------------------------------------------------

# FY 24 start through Jan 24
startDate = as.Date('2023-10-01')
endDate   = as.Date('2024-02-01')



# DATA =========================================================================

gcpe_base <- read_csv('Marketing/GPCE_Marketing_Expenses.csv')



## DATABASE CONNECTION =========================================================

marketingConfig <- tbl(database,                            # The database
                       in_schema(schema = 'DASH',           # The schema
                                 table  = 'GL_EXPENSE_CONFIG')) |>  # The table
  collect() 
# marketingConfig[marketingConfig == '0X0!OTHER'] <- NA

# Expense category tables to keep
expenseCategories    <- tbl(database,                            # The database
                            in_schema(schema = 'DASH',           # The schema
                                      table  = 'GL_EXPENSE_CATEGORY_DIM')) |>  # The table
  collect()
expenseSubCategories    <- tbl(database,                            # The database
                               in_schema(schema = 'DASH',           # The schema
                                         table  = 'GL_EXPENSE_SUBCATEGORY_DIM')) |>  # The table
  collect()

# Payroll and departments to keep
payrollConfig    <- tbl(database,                            # The database
                        in_schema(schema = 'DASH',           # The schema
                                  table  = 'GL_EXPENSE_MARKETING_PAYROLL_CONFIG_BUSINESS_DEPT')) |>  # The table
  collect()

payrollAccountConfig <- tbl(database,                            # The database
                            in_schema(schema = 'DASH',           # The schema
                                      table  = 'GL_EXPENSE_MARKETING_PAYROLL_CONFIG_ACCOUNT')) |>  # The table
  collect()

# Source prop names
sourcePropNames <- tbl(database,                            # The database
                       in_schema(schema = 'DASH',           # The schema
                                 table  = 'GL_EXPENSE_BUSINESS_SOURCE_PROP_DIM')) |>  # The table
  collect()


# Filter data
gcpe_filtered <- gcpe_base |> 
  mutate(TRX_DATE = as.Date(trimws(TRX_DATE), format = "%m/%d/%Y")) |>
  filter(TRX_DATE >= startDate & TRX_DATE < endDate) |> 
  
  # Update database name
  mutate(DBASE_NAME = if_else(DBASE_NAME == 'ASP' | DBASE_NAME == 'CNCP', 
                              'Other',
                              'CNDC')
  )



# Matching ---------------------------------------------------------------------


## PAYROLL ---------------------------------------------------------------------

df_payroll <- gcpe_filtered |> 
  
  # join to matching configured business and depts
  inner_join(payrollConfig,
             by = c('BUSINESS', 'DEPT')) |> 
  
  # only select accounts
  inner_join(payrollAccountConfig,
             by = 'ACCOUNT')


## MARKETING -------------------------------------------------------------------

### (1) ACCOUNT ONLY MUST MATCH ---------------------------------------------------

# Create unique table of accounts, with no specification of vendor or sub category
match_acct <- marketingConfig |> 
  filter(is.na(VENDORID) & is.na(SUB_ACCOUNT)) |> 
  distinct(ACCOUNT, GL_EXPENSE_CATEGORY_ID, GL_EXPENSE_SUBCATEGORY_ID) 

marketing_match_acct <- gcpe_filtered |> 
  
  # Filter out non matching account combos
  inner_join(match_acct, by = 'ACCOUNT')

# Validation
# marketing_match_acct |> distinct(ACCOUNT, GL_EXPENSE_CATEGORY_ID, GL_EXPENSE_SUBCATEGORY_ID)



### (2) ACCOUNT & VENDOR ID MUST MATCH --------------------------------------------

# Create unique table of account/vendor combos, add fuzzy lookup
match_acctAndVendor <- marketingConfig |> 
  distinct(ACCOUNT, VENDORID, GL_EXPENSE_CATEGORY_ID, GL_EXPENSE_SUBCATEGORY_ID) |> 
  drop_na()

marketing_match_acctAndVendor <- gcpe_filtered |> 
  
  # Filter out non matching account/vendor combos
  inner_join(match_acctAndVendor, by = c('ACCOUNT', 'VENDORID'))

# Validation
# marketing_match_acctAndVendor |> distinct(ACCOUNT, VENDORID, GL_EXPENSE_CATEGORY_ID, GL_EXPENSE_SUBCATEGORY_ID)



### (3) ACCOUNT & SUB_ACCOUNT MUST MATCH ------------------------------------------

# Create unique table of accounts and sub accounts, no specification of vendor
match_acctAndSubAcct <- marketingConfig |> 
  filter(is.na(VENDORID) & !is.na(SUB_ACCOUNT)) |> 
  distinct(ACCOUNT, SUB_ACCOUNT, GL_EXPENSE_CATEGORY_ID, GL_EXPENSE_SUBCATEGORY_ID) 

marketing_match_acctAndSubAcct <- gcpe_filtered |> 
  
  # Filter out non matching account combos
  inner_join(match_acctAndSubAcct, by = c('ACCOUNT', 'SUB_ACCT' = 'SUB_ACCOUNT'))

# Validation
# marketing_match_acctAndSubAcct |> distinct(ACCOUNT, SUB_ACCT, GL_EXPENSE_CATEGORY_ID, GL_EXPENSE_SUBCATEGORY_ID)



### JOIN MARKETING DATASETS ----------------------------------------------------

# Union marketing, `union` ensures no duplication (there should not be)
df_marketing <- marketing_match_acct |> 
  dplyr::union(marketing_match_acctAndVendor) |> 
  dplyr::union(marketing_match_acctAndSubAcct)
  

  
## JOIN ALL MATCHED PAYROLL + MARKETING ----------------------------------------

# Union marketing and payroll, `union` ensures no duplication (there should not be)
df <- dplyr::union(df_payroll, df_marketing) |> 
  
  left_join(sourcePropNames,
            by = 'BUSINESS') |> 
  
  # Line up names to database
  select(GL_EXPENSE_TYPE_CNDC_OTHER = DBASE_NAME,
         SOURCE_PROP,
         BUSINESS,
         BUSINESS_NAME,
         DEPT,
         DEPT_NAME,
         SUB_DEPT,
         ACCOUNT,
         ACCOUNT_NAME,
         SUB_ACCOUNT = SUB_ACCT,
         VENDORID,
         VENDNAME,
         TRX_DATE,
         GL_EXPENSE = NET_CHANGE,
         GL_EXPENSE_CATEGORY_ID,
         GL_EXPENSE_SUBCATEGORY_ID) 




# MONTHLY DATASET ==============================================================

df_monthly <- df |>
  
  # Month beginning
  mutate(TRX_DATE = floor_date(TRX_DATE, 'month')) |> 
  
  # Group by **month**
  group_by(GL_EXPENSE_TYPE_CNDC_OTHER,
           SOURCE_PROP, 
           TRX_DATE,
           GL_EXPENSE_CATEGORY_ID
           ) |> 
  summarise(TOTAL_GL_EXPENSE = sum(GL_EXPENSE)) |> 
  
  
  # ONLY TO ALIGN WITH DATES
  mutate(TOTAL_GL_EXPENSE_LAG_YEAR = NA,
         TOTAL_GL_EXPENSE_LAG_6WK  = NA)



# EXPORT DATASETS (DAILY & MONTHLY) ============================================

write_csv(df,         'Marketing/Data-Output/GL_EXPENSE_DAILY_R.csv')
write_csv(df_monthly, 'Marketing/Data-Output/GL_EXPENSE_MONTHLY_TOTALS_WITH_LAG_R.csv')
